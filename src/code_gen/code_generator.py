import re

from src.sym_table import Symbol, ClassSymbol

# use modified cdecl calling convention
# args are pushed on stack from RTL, caller cleans up, return value on stack

SP = '$SP'
BP = '$BP'  # - 0
AX = '$AX'  # return values, arithmetics
BX = '$BX'  # index
CX = '$CX'  # iterator
DX = '$DX'  # I/O & AX extension div/mul ?
EX = '$EX'  # misc
SI = '$SI'  # string src
DI = '$DI'  # string dest


# WARN: for some reason, stack grows up


def read_string():
    return f'''
LABEL readString
READS {AX}
SET [{SP}-1] {AX}
RETURN [{SP}+1]
'''


def read_int():
    return f'''
LABEL readInt
READI {AX}
SET [{SP}-1] {AX}
RETURN [{SP}+1]
'''


def length():
    return f'''
LABEL length
GETSIZE {AX} [{SP}-2]
{POP()}
SET [{SP}-1] {AX}
RETURN [{SP}+1]
'''


def PUSH(x=None):
    """my SP points to last full"""
    if x is None:
        return f'ADDI {SP}, {SP}, 1'
    else:
        return f'''ADDI {SP}, {SP}, 1
SET [{SP}] {x}'''


def POP(x=None):
    if x is None:
        return f'SUBI {SP}, {SP}, 1'
    else:
        return f'''SET {x} [{SP}]
SUBI {SP}, {SP}, 1'''


def LEAVE():
    """leave function (reset SP, BP, return)"""
    return f'''SET {SP} {BP}
{POP(BP)}
RETURN [{SP}]'''


def ENTER():
    return f'''{PUSH()} # space for PC
{PUSH(BP)}
SET {BP} {SP}'''


class CodeGenerator:
    def __init__(self):
        self.header = '''#! /bin/vypint
# VYPcode: 1.0
# Generated by xdokou14\n'''
        self.alias = '''
ALIAS BP $0
ALIAS AX $1
ALIAS BX $2
ALIAS CX $3
ALIAS DX $4
ALIAS EX $5
ALIAS SI $6
ALIAS DI $7\n'''
        self.body = ''
        self.variables = []

    def get_var_offset(self, symbol: str):
        return self.variables.index(symbol)

    def generate_code(self):
        self.prettifyOutput()
        print(self.header)
        print(self.alias)
        print("SET $BP $SP")
        print("CALL [$SP+1] main")
        print("JUMP _end\n")
        print(self.body)
        print("LABEL _end")

    def prettifyOutput(self):
        """add tabs"""

        def add_tabs(match):
            lines = match.group(0).split('\n')
            return '\n' + lines[0] + '\n' + '\n'.join('\t' + line if line else line for line in lines[1:])

        self.body = re.sub(r'LABEL.*?(?=LABEL|$)', add_tabs, self.body, flags=re.DOTALL)

    def declaration(self, symbol: Symbol):
        _name = symbol.name
        self.variables.append(_name)
        _type = symbol.data_type
        self.body += f'# declaration of {_name}\n'
        self.body += f'SET [{BP}+{self.get_var_offset(_name)}] 0\n'
        self.body += f'{PUSH()}\n\n'

    def print(self, symbol: [Symbol]):
        self.body += f'# print\n'

        for acc, s in enumerate(symbol, -len(symbol) + 1):
            acc = '' if acc == 0 else acc
            if s.data_type == 'int':
                self.body += f'WRITEI [{SP}{acc}]\n'
            else:
                self.body += f'WRITES [{SP}{acc}]\n'

    def fun_call(self, fname: str):
        self.body += f'# function call {fname}\n'
        self.body += f'{PUSH()} # space for return value\n'
        self.body += f'CALL [{SP}+1] {fname}\n\n'

    def literal(self, symbol: Symbol):
        if symbol.data_type == 'int':
            self._int_literal(symbol.name)
        else:
            self._string_literal(symbol.name)

    def _string_literal(self, value):
        self.body += f'# string literal {value}\n'
        self.body += f'CREATE {DI} 1\n'
        self.body += f'SETWORD {DI} 0 {value}\n'
        self.body += f'GETWORD {DI} {DI} 0\n'
        self.body += f'{PUSH(DI)}\n\n'

    def _int_literal(self, value):
        self.body += f'# int literal {value}\n'
        self.body += f'{PUSH(value)}\n\n'

    def restore_stack(self):
        _vars = len(self.variables)
        self.body += f'# restore stack\n'
        self.body += f'ADDI {SP} {BP} {_vars}\n\n'

    def function_def(self, fun_name):
        self.body += f'LABEL {fun_name}\n'
        self.body += f'{ENTER()}\n'

    def exit_function(self):
        self.body += f'# exit function\n'
        self.body += f'{LEAVE()}\n'

    def VMT(self, current_class: ClassSymbol):
        """VMT goes before functions"""
        methods = current_class.getVMT().keys()
        self.body += f'# VMT for {current_class.name}\n'
        self.body += f'CREATE {AX} {len(methods)}\n'
        for i, method in enumerate(methods):
            self.body += f'SETWORD {AX} {i} "{method}"\n'

        self.body += f'{PUSH(AX)}\n\n'
        #TODO: need to store it as "variable" as it's on stack
        self.body += '\n'
