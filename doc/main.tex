\documentclass[a4paper,11pt]{article}
\usepackage{graphicx}
\usepackage[left=2cm, top=3cm, text={17cm, 24cm}]{geometry}
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage{lipsum}
\usepackage[unicode]{hyperref}
\hypersetup{colorlinks = true, hypertexnames = false}

\begin{document}
	\begin{titlepage}
		\begin{center}
			\textsc{\Huge Vysoké učení technické v~Brně\\
				\vspace{0.4em}\huge Fakulta informačních technologií}

			\vspace{\stretch{0.382}}

			{\LARGE VYPA\,--\,compiler\\
				\Huge Vypcode Compiler\\ \vspace{0.3em}}

			\vspace{\stretch{0.318}}

			\textsc{{\LARGE Extensions}\\
				\vspace{0.4em} IFONLY \\
                    \vspace{0.4em} MINUS}

                \vspace{\stretch{.30}}


			{\Large \today \hfill Ladislav Dokoupil (\texttt{xdokou14})}
		\end{center}
	\end{titlepage}

    \section{Technologies}
    The project was created using Python3.13 and can be run using the Python interpreter via this command:
    \begin{verbatim}
        python3 vypcode.py <input_file> [<output_file>]
    \end{verbatim}
    where the output file is optional and defaults to \texttt{out.vc}.
    The grammar is defined using ANTLR4~\cite{antlr} and can be found in \texttt{Vypcode.g4} file.
    \texttt{antlr4} lexer and parser are generated using this command:
    \begin{verbatim}
        antlr4 Vyp.g4 -o src/antlr_src
    \end{verbatim}
    Furthermore, antlr4 creates listener class, which generates listener for entry and exit of each rule in grammar.
    This can be used to traverse the parse tree and create AST (Abstract Syntax Tree) or in our case,
    to generate code directly.


	\section{Implementations}
		In our approach we utilize syntax-directed translation,
        which means that translation is driven by the parser and the grammar rules.
        We use ANTLR4 to generate lexer and parser, which are then used to create a parse tree.
        We then traverse the parse tree generated by ANTLR4 using listener and generate code in the process.
        For most of the constructs we can directly generate upon entering the rule (top-down approach),
        for expressions, we need to wait until we know the result of the expression (bottom-up approach).
        Thus, exiting the rule is more suitable as we can forward information upward in the tree.

        Because object/function usage can precede their declaration, we need to utilize a 2-pass approach.
        In the first pass, we gather all the information about objects and functions, and in the second pass we generate code.
        Vypcode is generated directly from the parse tree traversal (no intermediate code) and is written to the output file specified in the command line.

        \subsection{Main}
            Entry point of the program, where we parse command-line arguments and run lexer and parser.
            Translation errors are caught here and translated into appropriate error codes according to the project specification.

       \subsection{Syntactic analysis}
            Syntactic analysis is handled entirely by ANTLR4, and error handling is carried out in the main function.

        \subsection{Symbol table}
            On the 1st pass of the tree traversal, we gather all the information about objects and functions.
            The function symbols are stored in the global scope, and the object symbols are stored in separate objects.
            Upon 2nd pass, scopes are pushed/popped as we traverse the tree and enter/leave code blocks.
            These scopes are used to store local variables and to semantically check the program.

       \subsection{Semantic analysis}
            As mentioned above, semantic analysis is performed in the second pass of the tree traversal.
            Semantic analysis takes care of:
            \begin{itemize}
                \item type checking
                \item redeclaration
                \item usage before declaration
                \item function argument count and type
                \item object member access
                \item expression type checking
                \item type casting check
                \item \textit{and more}
            \end{itemize}

            For type checking, we utilize class variable that stores the expression results (we can afford this because we use exit rules).
            For declarations, we check all symbol table scopes from the current scope to the global scope.

		\subsection {Code generation}
	            Code is generated directly from the parse tree traversal, where for each rule, we generate appropriate code.
                Because the tree is in the process of being traversed and error may yet occur, we store the generated code in an inner class variable.
                Upon entering \texttt{exitProgram} rule, we can be sure that no errors occurred, and we write the code to the output file.
                With this in mind, let us go through some of the design decisions made for the generated code.

                \subsubsection{Function calls}
                    After entering function we store a base pointer (BP) of a previous function.
                    The new base pointer separates the function arguments from the local variables, where:
                    \begin{itemize}
                        \item BP[1] is 1st variable of function
                        \item BP[0] is Base pointer for parent function
                        \item BP[-1] is return address
                        \item BP[-2] is last argument
                        \item \ldots
                        \item BP[-n] is first argument
                    \end{itemize}
                    Upon return to parent function, BP is restored and return to known return address is made.
                    Callee also cleans up the stack.
                    If return value is needed, it overwrites the first argument from the caller function, thus after return it will be on the top of the stack.
                    The top of the stack is tracked by the SP (Stack Pointer) register.

                \subsubsection{Expressions}
                    The expression results are stored on top of the stack.
                    Because of this decision, we can treat unary and binary expressions as stateless (the first operand is on top of the stack, and the second operand is below it).
                    Thus, if we encounter binary operations, we decrease SP and overwrite the second operand with the result of the operation.
                    Similarly, if we call function (which pushed arguments on the stack), we can treat the function call as any other operand.


                \subsubsection{Variable declaration}
                    When we encounter the declaration of the variable, we store the variable as a local variable on stack and its reference to BP.
                    Each time expression with this variable is encountered, we copy its value from BP to the top of the stack.
                    Upon assignment, we store the result in the original BP reference.


                \subsubsection{Virtual Method Table (VMT)}
                    Each class has a virtual method table, which is a list of function pointers defined as strings in format \texttt{class:function}.
                    Due to inheritance, the class can be a superclass of this class if it is not overridden.
                    The function is dynamically called by loading the object pointer to the top of the stack and then loading the function name as a pointer of the appropriate VMT record.


                \subsubsection{Object member access and method calls}
                    When an object is created, it creates memory on the heap as follows:
                    \begin{itemize}
                        \item 0: reference to self VMT
                        \item 1: reference to parent VMT
                        \item 2: string representation of the object (used for \texttt{getClass} method)
                        \item 3: field 1
                        \item \ldots
                        \item n: field n - 2
                    \end{itemize}
                    When an object is accessed, we load the object pointer to the top of the stack and then load the field index from the object.
                    When object method is called, we also load the object pointer on stack before calling the function,
                    thus it becomes the first argument of the function, and this/super can be used in the function body.

                \subsubsection{Built-in functions}
                    Built-in functions are hardcoded in the compiler and always added to the output code.
                    \begin{itemize}
                        \item \texttt{readString} - reads string from stdin
                        \item \texttt{readInt} - reads integer from stdin
                        \item \texttt{length} - returns length of the string
                        \item \texttt{Object:toString} - returns string representation of the object
                        \item \texttt{Object:getClass} - returns heap address of the class
                        \item \texttt{\_\_str\_concat\_\_} - hidden function for string concatenation (used by + operator)
                    \end{itemize}


    \section{bibliography}
        \begin{bibliography}{}
            \bibitem{antlr}
            Terence Parr
            \textit{The Definitive ANTLR 4 Reference}
            \url{https://www.fit.vutbr.cz/study/courses/VYPa/private/materials/parr-antlrv4_reference_2012}

            \bibitem{VYPA}
            Alexander Meduna, Roman Lukáš, Zbyněk Křivka.
            \textit{VYPa presentations}.
        \end{bibliography}
\end{document}
