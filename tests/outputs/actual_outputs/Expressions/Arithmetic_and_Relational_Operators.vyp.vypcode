#! /bin/vypint
# VYPcode: 1.0
# Generated by xdokou14

ALIAS BP $0
ALIAS AX $1
ALIAS BX $2
ALIAS CX $3
ALIAS OBJ $4
ALIAS EX $5
ALIAS SI $6
ALIAS DI $7

# VMT for Object
CREATE $AX 2
SETWORD $AX 0 "Object:toString"
SETWORD $AX 1 "Object:getClass"
SET [$SP] $AX
ADDI $SP, $SP, 1


SET $BP $SP
CALL [$SP+1] main
JUMP _end


# User program
LABEL main
	ADDI $SP, $SP, 1 # space for PC
	ADDI $SP, $SP, 1
	SET [$SP] $BP
	SET $BP $SP
	# declare a
	SET [$BP+1] 0
	ADDI $SP, $SP, 1
	
	# declare b
	SET [$BP+2] 0
	ADDI $SP, $SP, 1
	
	# restore stack
	ADDI $SP $BP 2
	
	# int literal 10
	ADDI $SP, $SP, 1
	SET [$SP] 10
	
	# assign var a
	SET [$BP+1] [$SP]
	
	# restore stack
	ADDI $SP $BP 2
	
	# int literal 20
	ADDI $SP, $SP, 1
	SET [$SP] 20
	
	# assign var b
	SET [$BP+2] [$SP]
	
	# restore stack
	ADDI $SP $BP 2
	
	# string literal "Sum: "
	CREATE $DI 1
	SETWORD $DI 0 "Sum: "
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI
	
	# push object ref a
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+1]
	# push object ref b
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+2]
	# binary operation: +
	ADDI $AX [$SP-1] [$SP]
	
	SUBI $SP, $SP, 1
	SET [$SP] $AX
	
	# string literal ", Difference: "
	CREATE $DI 1
	SETWORD $DI 0 ", Difference: "
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI
	
	# push object ref b
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+2]
	# push object ref a
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+1]
	# binary operation: -
	SUBI $AX [$SP-1] [$SP]
	
	SUBI $SP, $SP, 1
	SET [$SP] $AX
	
	# string literal "\n"
	CREATE $DI 1
	SETWORD $DI 0 "\n"
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI
	
	# print
	WRITES [$SP-4]
	WRITEI [$SP-3]
	WRITES [$SP-2]
	WRITEI [$SP-1]
	WRITES [$SP]
	# restore stack
	ADDI $SP $BP 2
	
	# string literal "Is a less than b? "
	CREATE $DI 1
	SETWORD $DI 0 "Is a less than b? "
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI
	
	# push object ref a
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+1]
	# push object ref b
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+2]
	# binary operation: <
	LTI $AX [$SP-1] [$SP]
	
	SUBI $SP, $SP, 1
	SET [$SP] $AX
	
	# string literal "\n"
	CREATE $DI 1
	SETWORD $DI 0 "\n"
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI
	
	# print
	WRITES [$SP-2]
	WRITEI [$SP-1]
	WRITES [$SP]
	# restore stack
	ADDI $SP $BP 2
	
	# exit function
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 1
	SUBI $SP, $SP, 1
	RETURN [$SP+1]
	
LABEL readString
	READS $AX
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL readInt
	READI $AX
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL length
	GETSIZE $AX [$SP]
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL subStr
	ADDI $SP $SP 2
	SET [$SP] $BP
	SET $BP $SP
	#[BP-2] = n, [BP-3] = i, [BP-4] = str
	SET $BX [$BP-3] # i
	
	GETSIZE $AX [$BP-4]
	LTI $EX $BX 0
	GTI $OBJ $BX $AX
	OR $EX $EX $OBJ # i < 0 || i > size
	
	CREATE $DI 1
	SETWORD $DI 0 ""
	JUMPNZ subStr_end $EX
	
	RESIZE $DI [$BP-2]
	
	SET $EX [$BP-2]
	ADDI $EX $EX $BX # n + i
	
	GTI $CX $EX $AX # n + i > size
	JUMPNZ subStr_min_else $CX
	JUMP subStr_min_end # n + 1 <= size
	LABEL subStr_min_else # n + i > size
	SET $EX [$BP-4]
	LABEL subStr_min_end
	#SUBI $EX $EX 1
	ADDI $SP $SP 1
	SET [$SP] $EX # [$SP]=min(n+i,len(str))- 1
	
	
	SET $AX 0 #index new
	#SET $BX $BX #index old
	LABEL subStr_start_while
	LTI $EX $BX [$SP] # i < n+i-1
	JUMPZ subStr_end $EX
	
	
	GETWORD $EX [$BP-4] $BX # EX=[$BP-4][$BX] - char from SI
	
	SETWORD $DI $AX $EX # rewrite char
	
	ADDI $AX $AX 1
	ADDI $BX $BX 1
	JUMP subStr_start_while
	
	
	LABEL subStr_end
	# exit function
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 4
	SET [$SP] $DI
	RETURN [$SP+3]
	
LABEL Object:toString
	INT2STRING $AX [$SP]
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL Object:getClass
	GETWORD $AX [$SP] 2
	SET [$SP] $AX
	RETURN [$SP+1]
	
	
LABEL _end
