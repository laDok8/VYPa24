#! /bin/vypint
# VYPcode: 1.0
# Generated by xdokou14

ALIAS BP $0
ALIAS AX $1
ALIAS BX $2
ALIAS CX $3
ALIAS OBJ $4
ALIAS EX $5
ALIAS SI $6
ALIAS DI $7

# VMT for Object
CREATE $AX 2
SETWORD $AX 0 "Object:toString"
SETWORD $AX 1 "Object:getClass"
SET [$SP] $AX
ADDI $SP, $SP, 1

# VMT for Circle
CREATE $AX 2
SETWORD $AX 0 "Object:toString"
SETWORD $AX 1 "Object:getClass"
SET [$SP] $AX
ADDI $SP, $SP, 1


SET $BP $SP
CALL [$SP+1] main
JUMP _end


# User program
LABEL main
	ADDI $SP, $SP, 1 # space for PC
	ADDI $SP, $SP, 1
	SET [$SP] $BP
	SET $BP $SP
	# declare c
	SET [$BP+1] 0
	ADDI $SP, $SP, 1
	
	# restore stack
	ADDI $SP $BP 1
	
	# new Circle
	CREATE $AX 3
	SETWORD $AX 0 [1]
	SETWORD $AX 1 [0]
	SETWORD $AX 2 "Circle"
	
	ADDI $SP, $SP, 1
	SET [$SP] $AX
	# assign var c
	SET [$BP+1] [$SP]
	
	# restore stack
	ADDI $SP $BP 1
	
	# string literal "Class: "
	CREATE $DI 1
	SETWORD $DI 0 "Class: "
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI
	
	# push object ref c
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+1]
	SET $OBJ [$SP]
	
	# class function call Object:getClass
	GETWORD $AX $OBJ 0 # GET VMT
	GETWORD $AX $AX 1 # GET DYNAMIC FUN REF
	CALL [$SP+1] $AX # CALL DYNAMIC FUN
	
	# string literal "\n"
	CREATE $DI 1
	SETWORD $DI 0 "\n"
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI
	
	# print
	WRITES [$SP-2]
	WRITES [$SP-1]
	WRITES [$SP]
	# restore stack
	ADDI $SP $BP 1
	
	# exit function
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 1
	SUBI $SP, $SP, 1
	RETURN [$SP+1]
	
LABEL readString
	READS $AX
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL readInt
	READI $AX
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL length
	GETSIZE $AX [$SP]
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL subStr
	ADDI $SP $SP 2
	SET [$SP] $BP
	SET $BP $SP
	#[BP-2] = n, [BP-3] = i, [BP-4] = str
	SET $BX [$BP-3] # i
	
	GETSIZE $AX [$BP-4]
	LTI $EX $BX 0
	GTI $OBJ $BX $AX
	OR $EX $EX $OBJ # i < 0 || i > size
	
	CREATE $DI 1
	SETWORD $DI 0 ""
	JUMPNZ subStr_end $EX
	
	RESIZE $DI [$BP-2]
	
	SET $EX [$BP-2]
	ADDI $EX $EX $BX # n + i
	
	GTI $CX $EX $AX # n + i > size
	JUMPNZ subStr_min_else $CX
	JUMP subStr_min_end # n + 1 <= size
	LABEL subStr_min_else # n + i > size
	SET $EX [$BP-4]
	LABEL subStr_min_end
	#SUBI $EX $EX 1
	ADDI $SP $SP 1
	SET [$SP] $EX # [$SP]=min(n+i,len(str))- 1
	
	
	SET $AX 0 #index new
	#SET $BX $BX #index old
	LABEL subStr_start_while
	LTI $EX $BX [$SP] # i < n+i-1
	JUMPZ subStr_end $EX
	
	
	GETWORD $EX [$BP-4] $BX # EX=[$BP-4][$BX] - char from SI
	
	SETWORD $DI $AX $EX # rewrite char
	
	ADDI $AX $AX 1
	ADDI $BX $BX 1
	JUMP subStr_start_while
	
	
	LABEL subStr_end
	# exit function
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 4
	SET [$SP] $DI
	RETURN [$SP+3]
	
LABEL Object:toString
	INT2STRING $AX [$SP]
	SET [$SP] $AX
	RETURN [$SP+1]
	
LABEL Object:getClass
	GETWORD $AX [$SP] 2
	SET [$SP] $AX
	RETURN [$SP+1]
	
	
LABEL _end
