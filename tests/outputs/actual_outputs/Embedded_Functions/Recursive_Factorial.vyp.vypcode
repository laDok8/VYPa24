#! /bin/vypint
# VYPcode: 1.0
# Generated by xdokou14

ALIAS BP $0
ALIAS AX $1
ALIAS BX $2
ALIAS CX $3
ALIAS DX $4
ALIAS EX $5
ALIAS SI $6
ALIAS DI $7
SET $BP $SP
CALL [$SP+1] main
JUMP _end

# VMT for Object
CREATE $AX 2
SETWORD $AX 0 "toString"
SETWORD $AX 1 "getClass"
ADDI $SP, $SP, 1
SET [$SP] $AX



LABEL main
	ADDI $SP, $SP, 1 # space for PC
	ADDI $SP, $SP, 1
	SET [$SP] $BP
	SET $BP $SP
	# declare a
	SET [$BP+1] 0
	ADDI $SP, $SP, 1

	# restore stack
	ADDI $SP $BP 1

	# declare res
	SET [$BP+2] 0
	ADDI $SP, $SP, 1

	# restore stack
	ADDI $SP $BP 2

	# string literal "Enter an integer to compute its factorial:"
	CREATE $DI 1
	SETWORD $DI 0 "Enter an integer to compute its factorial:"
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI

	# print
	WRITES [$SP]
	# restore stack
	ADDI $SP $BP 2

	# function call readInt
	ADDI $SP, $SP, 1 # space for return value
	CALL [$SP+1] readInt

	# assign var a
	SET [$BP+1] [$SP]

	# restore stack
	ADDI $SP $BP 2

	# push object ref a
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+1]

	# int literal 0
	ADDI $SP, $SP, 1
	SET [$SP] 0

	# binary operation: <
	LTS $AX [$SP] [$SP-1]

	SUBI $SP, $SP, 1
	SET [$SP] $AX

	# string literal "\nFactorial of a negative integer is undefined!\n"
	CREATE $DI 1
	SETWORD $DI 0 "\nFactorial of a negative integer is undefined!\n"
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI

	# print
	WRITES [$SP]
	# restore stack
	ADDI $SP $BP 2

	# string literal "\nThe result is: "
	CREATE $DI 1
	SETWORD $DI 0 "\nThe result is: "
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI

	# push object ref a
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+1]

	# function call factorial
	ADDI $SP, $SP, 1 # space for return value
	CALL [$SP+1] factorial

	# string literal "\n"
	CREATE $DI 1
	SETWORD $DI 0 "\n"
	GETWORD $DI $DI 0
	ADDI $SP, $SP, 1
	SET [$SP] $DI

	# print
	WRITES [$SP-2]
	WRITEI [$SP-1]
	WRITES [$SP]
	# restore stack
	ADDI $SP $BP 2

	# restore stack
	ADDI $SP $BP 2

	# exit function
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 1
	SUBI $SP, $SP, 1
	RETURN [$SP+1]

LABEL factorial
	ADDI $SP, $SP, 1 # space for PC
	ADDI $SP, $SP, 1
	SET [$SP] $BP
	SET $BP $SP
	# declare decremented_n
	SET [$BP+3] 0
	ADDI $SP, $SP, 1

	# restore stack
	ADDI $SP $BP 3

	# declare temp_result
	SET [$BP+4] 0
	ADDI $SP, $SP, 1

	# restore stack
	ADDI $SP $BP 4

	# push object ref n
	ADDI $SP, $SP, 1
	SET [$SP] [$BP-4]

	# int literal 2
	ADDI $SP, $SP, 1
	SET [$SP] 2

	# binary operation: <
	LTS $AX [$SP] [$SP-1]

	SUBI $SP, $SP, 1
	SET [$SP] $AX

	# int literal 1
	ADDI $SP, $SP, 1
	SET [$SP] 1

	# return value
	SET [$BP-2] [$SP]
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 1
	SUBI $SP, $SP, 1
	RETURN [$SP+1]

	# restore stack
	ADDI $SP $BP 4

	# push object ref n
	ADDI $SP, $SP, 1
	SET [$SP] [$BP-4]

	# int literal 1
	ADDI $SP, $SP, 1
	SET [$SP] 1

	# binary operation: -
	SUBI $AX [$SP] [$SP-1]

	SUBI $SP, $SP, 1
	SET [$SP] $AX

	# assign var decremented_n
	SET [$BP+3] [$SP]

	# restore stack
	ADDI $SP $BP 4

	# push object ref decremented_n
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+3]

	# function call factorial
	ADDI $SP, $SP, 1 # space for return value
	CALL [$SP+1] factorial

	# assign var temp_result
	SET [$BP+4] [$SP]

	# restore stack
	ADDI $SP $BP 4

	# restore stack
	ADDI $SP $BP 4

	# push object ref n
	ADDI $SP, $SP, 1
	SET [$SP] [$BP-4]

	# push object ref temp_result
	ADDI $SP, $SP, 1
	SET [$SP] [$BP+4]

	# binary operation: *
	MULI $AX [$SP] [$SP-1]

	SUBI $SP, $SP, 1
	SET [$SP] $AX

	# return value
	SET [$BP-2] [$SP]
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 1
	SUBI $SP, $SP, 1
	RETURN [$SP+1]

	# restore stack
	ADDI $SP $BP 4

	# exit function
	SET $SP $BP
	SET $BP [$SP]
	SUBI $SP, $SP, 1
	SUBI $SP, $SP, 1
	RETURN [$SP+1]

LABEL _end
